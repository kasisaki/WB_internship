package task_16

import (
	"cmp"
	"fmt"
	"math/rand"
)

func Quicksort[S cmp.Ordered](s []S) {

	l := len(s)
	// Если срез пустой или в нем только один элемент, то нечего сортировать
	if l < 2 {
		return //
	}

	// Если массив состоит из двух значений, то смысла дальше идти нет и просто сортируем их на месте и выходим
	if l == 2 {
		if s[0] > s[1] {
			s[0], s[1] = s[1], s[0]
		}
		return // точка выхода
	}
	// Выбираем опорный элемент, левый и правый индексы
	// опорный элемент выбирается случайным образом для снижения вероятности возможности злонамеренного подбора наиболее неподходящих(сложных) входных данных
	pivotIdx := rand.Intn(len(s) - 1)
	leftIdx, rightIdx := 0, l-2

	// перемещаем в конец опорное значение
	s[pivotIdx], s[l-1] = s[l-1], s[pivotIdx]
	pivot := s[l-1]
	//fmt.Printf("Arr: %v, pivot[%d]\n", s, pivotIdx)

	for leftIdx < rightIdx {
		// Двигаем левый указатель вправо, пока не найдем элемент, больший или равный опорному.
		for s[leftIdx] < pivot && leftIdx < rightIdx {
			leftIdx++
		}
		// Двигаем правый указатель влево, пока не найдем элемент, меньший или равный опорному.
		for s[rightIdx] > pivot && leftIdx < rightIdx {
			rightIdx--
		}
		// сравниваем значение под левым и правым индексом и меняем местами, если левый больше правого
		if s[leftIdx] > s[rightIdx] {
			s[leftIdx], s[rightIdx] = s[rightIdx], s[leftIdx]
		}
	}
	// Определяем новое положение опорного значения: если опорное меньше значения под правым индексом, то они поменяются местами
	if s[rightIdx] > pivot {
		s[rightIdx], s[pivotIdx] = s[pivotIdx], s[rightIdx]
	}

	Quicksort(s[:leftIdx+1])
	Quicksort(s[rightIdx:])

	return
}

func main() {
	a := []int{8, 3, 1, 4, 2, 0}

	fmt.Println(a)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(a))
	Quicksort(a)
	fmt.Println(a)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(a))
	fmt.Println("------==------")

	b := []int{175, 13, 28, 45, 62, 112, 3, 91, -50, 59, 32, 89, 21, 37, 14, 97, 58, 71, 126, -95, 79, 87, 117, 17, 108, 34, 90, 19, 75, 1, 23, 106, -127, 114, 8, 115, 15, 99, 118, 98, 56, 73, 42, 116, 48, 5, 78, 51, 77, 72, 111, 41, 80, 67, 2, 44, 124, 55, 125, 93, 76, 74, 85, 20, 60, 33, 54, 110, 94, 101, 53, 66, 26, 9, 49, 18, 61, 84, 96, 35, 46, 104, 43, 36, 86, 105, 4, 40, 24, 100, 39, 65, 81, 64, 82, 69, 102, 92, 11, 29, 68, 109, 7, 63, 22, 52, 83, 38, 31, 10, 121, 70, 57, 30, 47, 107, 16, 120, 119, 12, 122, 88, 28, 103, 6, 25, 123}
	fmt.Println(b)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(b))
	Quicksort(b)
	fmt.Println(b)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(b))
	fmt.Println("------==------")

	c := []uint{1, 0, 5}
	fmt.Println(c)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(c))
	Quicksort(c)
	fmt.Println(c)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(c))
	fmt.Println("------==------")

	d := []int64{4502173431061863011, -4297449147060103566, 6764417894258947550, -8606200431582371204, 1200962545867712986, 218212927327212052, 4429103011938011292, 8255726591482054640, -2408789490946182752, 8203619070719432790, 8141987515810274864, 2448411683599708416, -9223372036854775808, 1948315586032686902, 7944213546485411495, 3311026438781962396, 7538812873309948274, -1023760257383778816, -9188562050311550805, 3352911206554834471, -7110910989297110375, -1180743594582116718, 1999117666866110819, 1586547656797836064, 8033418214379111922, -364019528628320899, -5019710531624764468, 4925244110250615619, 983556287500214593, -624261790174351932, 1518262764544494098, -2304295466237786956, 1750281729054335315, -8446678808417165375, 4759962688591419330, -5573856487594682889, 6069943120071591992, -1466267052767756454, 7395269732598995696, -8722077802231914660, -1325850714279980761, -3573535666713725498, 632940308634379581, 8414827586082082423, -6673830528536117614, 1808045115197856053, 5567644082610790691, -1803194404379649860, 9223372036854775807, -254480001031884121, 5408547857654396496, -1359091714844980072, -8104710619346302785, 8999178318849262312, -6543946526693133075, 8672195796399482640, -757398804670028574, -1807783556888135017, -4598894275089514145, 604594926451517345, 3117507838430799474, 3451759305749228607, 862894411004778842, -4811144952341718855, 6680166289202880437, 1480372309442621299, 3201917767451723171, 3946117271095395710, 5387811623809159285, 3617742261208598034, 4146151467510553182, 3533980627853393661, 4128601302530519426, 2272868424679270460, -7265477762646753974, 2499923335144174779, 5757427688265478064, 2877857741880473949, -3914605707753892490, -6310182428293625278, -1103629293482293588, 7841965541716587534, 1857321393608597289, 3020622621524438861, -4075531894601414857, -8306830818985420377, -5589530714668606741, 6350278854518585465, -3884687823891397424, 4259099204905738466, 4865603800049727226, -7713460110996926076, -2724155156533047814, 1537342157307275906, 4266353755711822683, 3015233213649221533, 4291543896074828183, 4679058444774946346, -8600532234258564345, -2707683068582286643, -4463125323329949577, 5800421076077136813, -3033109292385009571, -3577560129963206485, 8332310494594078448, -3734418650010131184, 9222674533733976951, -4788514292956908571, 6233637189488154207, -3292408239676434171, -2758491063453200577, 588605068646375095, -5163490024665051808, 4401836044711882068, -6133984950497856466, -8733351419343454646, 3918318756746972188, 4320298568253176378}
	fmt.Println(d)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(d))
	Quicksort(d)
	fmt.Println(d)
	fmt.Printf("Срез отсортирован: %v\n", checkSorted(d))
	fmt.Println("------==------")

	// тут сортировать нечего, но проверим на возникновение паники
	Quicksort([]int{})
	Quicksort([]int{55})

}

func checkSorted[S cmp.Ordered](s []S) bool {
	if len(s) < 2 {
		return true
	}
	start := true
	for i, n := range s {
		if start {
			start = !start
			continue
		}
		if s[i-1] > n {
			return false
		}
	}
	return true
}
